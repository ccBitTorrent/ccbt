---
description: Terminal dashboard implementation patterns using Textual framework
globs: ccbt/interface/**/*.py
---

# Terminal Dashboard Implementation Guide

This rule covers patterns and best practices for implementing the Textual-based terminal dashboard in `ccbt/interface/`.

## Module Structure

The interface module follows a modular architecture:

```
ccbt/interface/
├── terminal_dashboard.py    # Main App class and entry points
├── widgets/                 # Reusable UI components
│   ├── core_widgets.py     # Overview, TorrentsTable, PeersTable, SpeedSparklines
│   └── reusable_widgets.py # ProgressBarWidget, MetricsTableWidget, SparklineGroup
├── screens/                 # Screen components
│   ├── base.py             # Base classes (ConfigScreen, MonitoringScreen)
│   ├── dialogs.py          # Modal dialogs (AddTorrentScreen)
│   ├── monitoring/         # Monitoring screens (15 screens)
│   ├── config/             # Configuration screens (7 screens)
│   └── utility/            # Utility screens (Help, Navigation, FileSelection)
└── commands/               # Command execution
    └── executor.py         # CommandExecutor class
```

## Import Patterns

### Textual Import Handling

Always use TYPE_CHECKING blocks and fallback classes for Textual imports:

```python
from __future__ import annotations

from typing import TYPE_CHECKING, Any, ClassVar

if TYPE_CHECKING:
    from textual.app import App, ComposeResult
    from textual.screen import Screen
    from textual.widgets import Static, DataTable
else:
    try:
        from textual.app import App, ComposeResult
        from textual.screen import Screen
        from textual.widgets import Static, DataTable
    except ImportError:
        # Fallback classes for when textual is not available
        class App:  # type: ignore[misc]
            """Fallback App class when textual is not available."""
        
        class Screen:  # type: ignore[no-redef]
            """Fallback Screen class."""
        
        class Static:  # type: ignore[no-redef]
            """Fallback Static widget."""
        
        ComposeResult = None  # type: ignore[assignment, misc]
```

### Container Imports

For containers, handle the fallback case:

```python
try:
    from textual.containers import Container, Horizontal, Vertical
except ImportError:
    from typing import Any as ComposeResult
    Container = None  # type: ignore[assignment, misc]
    Horizontal = None  # type: ignore[assignment, misc]
    Vertical = None  # type: ignore[assignment, misc]
```

## Screen Implementation

### Base Screen Pattern

All screens should inherit from base classes in [ccbt/interface/screens/base.py](mdc:ccbt/interface/screens/base.py):

- **MonitoringScreen**: For monitoring/metrics screens
- **ConfigScreen**: For configuration screens
- **Screen**: For utility screens

Example monitoring screen:

```python
from ccbt.interface.screens.base import MonitoringScreen

class SystemResourcesScreen(MonitoringScreen):  # type: ignore[misc]
    """Screen to display system resource usage."""
    
    CSS = """
    #content {
        height: 1fr;
        overflow-y: auto;
    }
    """
    
    def compose(self) -> ComposeResult:  # pragma: no cover
        """Compose the screen."""
        yield Header()
        with Vertical():
            yield Static(id="content")
        yield Footer()
    
    async def _refresh_data(self) -> None:  # pragma: no cover
        """Refresh screen data."""
        content = self.query_one("#content", Static)
        # Update content...
```

### CSS Patterns

- Define CSS as class variable `CSS` (string)
- Use `#id` selectors for specific widgets
- Use layout containers: `height: 1fr` for flexible sizing
- Use `overflow-y: auto` for scrollable content
- Reference Textual design tokens: `$primary`, `$surface`, etc.

### Compose Pattern

Always use the `compose()` method with `yield`:

```python
def compose(self) -> ComposeResult:  # pragma: no cover
    """Compose the screen."""
    yield Header()
    with Vertical():
        yield Static(id="content")
        yield DataTable(id="table")
    yield Footer()
```

### Event Handling

- Use `on_mount()` for initialization
- Use `on_unmount()` for cleanup
- Use `action_*` methods for keyboard bindings
- Use `on_*` methods for widget events (e.g., `on_button_pressed`)

### Bindings

Define keyboard bindings as class variable:

```python
BINDINGS: ClassVar[list[tuple[str, str, str]]] = [
    ("escape", "back", "Back"),
    ("q", "quit", "Quit"),
    ("r", "refresh", "Refresh"),
]
```

## Widget Implementation

### Widget Base Classes

Widgets extend Textual widgets (usually `Static`):

```python
from textual.widgets import Static

class Overview(Static):  # type: ignore[misc]
    """Simple widget to render global stats."""
    
    def update_from_stats(self, stats: dict[str, Any]) -> None:
        """Update widget with statistics."""
        # Use Rich for formatting
        from rich.table import Table
        from rich.panel import Panel
        
        table = Table()
        # Build table...
        self.update(Panel(table, title="Overview"))
```

### Widget Patterns

- Use `update()` method to change widget content
- Use Rich library for formatting (Table, Panel, etc.)
- Use Rich `Text` for colored segments and complex formatting
- Keep widgets focused on single responsibility
- Export widgets through `widgets/__init__.py`
- **Always wrap user-facing strings** with `_()` for i18n

### Health Bar Widgets

For health monitoring widgets (e.g., piece availability), use colored segments:

```python
from textual.widgets import Static
from rich.text import Text
from ccbt.i18n import _

class PieceAvailabilityHealthBar(Static):  # type: ignore[misc]
    """Widget to display piece availability as a colored health bar."""
    
    DEFAULT_CSS = """
    PieceAvailabilityHealthBar {
        height: 1;
        width: 1fr;
    }
    """
    
    def update_availability(self, availability: list[int], max_peers: int | None = None) -> None:
        """Update health bar with piece availability data."""
        # Build colored bar with thin segments
        bar_text = Text()
        for peer_count in availability:
            color = self._get_color_for_availability(peer_count)
            bar_text.append("▌", style=color)  # Thin bar character
        
        # Add summary label
        label = Text()
        label.append(f" {_('Health')}: ", style="cyan")
        label.append(f"{availability_pct:.1f}%", style="green")
        
        full_text = Text()
        full_text.append(bar_text)
        full_text.append(" ")
        full_text.append(label)
        self.update(full_text)
```

### Color Coding Patterns

- **Green**: High availability/health (≥70% or high value)
- **Yellow**: Medium availability/health (40-70%)
- **Orange**: Low availability/health (20-40%)
- **Red**: Very low availability/health (<20% or critical)
- **Gray**: Not available or no data

## Configuration Screens

Configuration screens inherit from `ConfigScreen`:

```python
from ccbt.interface.screens.base import ConfigScreen

class SSLConfigScreen(ConfigScreen):  # type: ignore[misc]
    """Screen to manage SSL/TLS configuration."""
    
    CSS = """..."""
    BINDINGS: ClassVar[list[tuple[str, str, str]]] = [...]
    
    def compose(self) -> ComposeResult:
        """Compose configuration screen."""
        # Use ConfigValueEditor and ConfigSectionWidget from
        # ccbt/interface/screens/config/widgets.py
```

## Data Access Pattern

**CRITICAL**: The interface must use `DataProvider` for all read operations and `CommandExecutor` for all write operations. Never access session internals directly.

### DataProvider Pattern

Use `DataProvider` from [ccbt/interface/data_provider.py](mdc:ccbt/interface/data_provider.py) to access torrent data:

```python
from ccbt.interface.data_provider import DataProvider

class MyScreen(Screen):
    def __init__(self, data_provider: DataProvider, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self._data_provider = data_provider
    
    async def refresh_data(self):
        """Refresh data using DataProvider."""
        # Read operations use DataProvider
        stats = await self._data_provider.get_global_stats()
        torrents = await self._data_provider.list_torrents()
        status = await self._data_provider.get_torrent_status(info_hash)
        peers = await self._data_provider.get_torrent_peers(info_hash)
        files = await self._data_provider.get_torrent_files(info_hash)
        trackers = await self._data_provider.get_torrent_trackers(info_hash)
        availability = await self._data_provider.get_torrent_piece_availability(info_hash)
        metrics = await self._data_provider.get_metrics()
```

### CommandExecutor Pattern

Use `CommandExecutor` from [ccbt/interface/commands/executor.py](mdc:ccbt/interface/commands/executor.py) for all write operations:

```python
from ccbt.interface.commands.executor import CommandExecutor

class MyScreen(Screen):
    def __init__(self, data_provider: DataProvider, command_executor: CommandExecutor, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self._data_provider = data_provider
        self._command_executor = command_executor
    
    async def action_pause_torrent(self):
        """Pause torrent using executor."""
        result = await self._command_executor.execute_command(
            "torrent.pause", info_hash=info_hash
        )
        if result and hasattr(result, "success") and result.success:
            self.app.notify("Torrent paused", severity="success")
```

### Daemon Access Rules

- **Read operations**: Always use `DataProvider` methods (never direct IPC client calls)
- **Write operations**: Always use `CommandExecutor.execute_command()` (never direct session calls)
- **Never access**: `self.session` internals directly when using daemon
- **Exception**: Local sessions can access `self.session` directly, but prefer DataProvider/Executor for consistency

## Module Exports

### Widgets Module

Export all widgets in [ccbt/interface/widgets/__init__.py](mdc:ccbt/interface/widgets/__init__.py):

```python
from ccbt.interface.widgets.core_widgets import (
    Overview,
    PeersTable,
    SpeedSparklines,
    TorrentsTable,
)
from ccbt.interface.widgets.reusable_widgets import (
    MetricsTableWidget,
    ProgressBarWidget,
    SparklineGroup,
)

__all__ = [
    "MetricsTableWidget",
    "Overview",
    "PeersTable",
    "ProgressBarWidget",
    "SparklineGroup",
    "SpeedSparklines",
    "TorrentsTable",
]
```

### Screens Module

Export base classes in [ccbt/interface/screens/__init__.py](mdc:ccbt/interface/screens/__init__.py). Individual screens are imported directly from their modules.

## Main Dashboard

The main dashboard in [ccbt/interface/terminal_dashboard.py](mdc:ccbt/interface/terminal_dashboard.py) contains:

- `TerminalDashboard` class (extends `App`)
- `run_dashboard()` function
- `main()` function (CLI entry point)

All screens and widgets are imported from their respective modules.

## Rich Integration

Use Rich library for formatting:

- `Panel`: For bordered content areas
- `Table`: For tabular data
- Rich markup: `[bold]`, `[cyan]`, `[green]`, etc.

Example:

```python
from rich.panel import Panel
from rich.table import Table

table = Table(title="Metrics", expand=True)
table.add_column("Metric", style="cyan", ratio=1)
table.add_column("Value", style="green", ratio=2)
table.add_row("CPU", "45%")

content.update(Panel(table, title="System Resources"))
```

## Type Hints

- Use `ComposeResult` for `compose()` return type
- Use `TYPE_CHECKING` blocks for type-only imports
- Use `# type: ignore[misc]` for Textual base classes
- Use `# pragma: no cover` for UI code that's hard to test

## Error Handling

- Always handle Textual import failures gracefully
- Use try/except blocks for async operations
- Display errors in UI using Rich Panels with `border_style="red"`

## Testing Considerations

- Mark UI code with `# pragma: no cover`
- Use integration tests for screen behavior
- Mock Textual widgets in unit tests
- Test fallback behavior when Textual is unavailable


## i18n Integration

### String Wrapping

All user-facing strings must be wrapped with `_()`:

```python
from ccbt.i18n import _

# In bindings
BINDINGS: ClassVar[list[tuple[str, str, str]]] = [
    ("p", "pause", _("Pause")),
    ("r", "resume", _("Resume")),
]

# In notifications
self.app.notify(_("Torrent paused"), severity="success")

# In table headers
table.add_column(_("Name"), style="cyan")

# In widget labels
label.append(f" {_('Health')}: ", style="cyan")
```

### Language Selector

Use `LanguageSelectorWidget` from [ccbt/interface/widgets/language_selector.py](mdc:ccbt/interface/widgets/language_selector.py) to allow users to change interface language:

```python
from ccbt.interface.widgets.language_selector import LanguageSelectorWidget

def compose(self) -> ComposeResult:
    with Vertical():
        yield LanguageSelectorWidget(data_provider, command_executor)
```

## Tabbed Interface Structure

The interface uses a tabbed structure with nested tabs:

### Main Tabs

1. **Torrents Tab**: Lists all torrents with nested sub-tabs (global, downloading, seeding, completed, active, inactive)
2. **Per-Torrent Tab**: Detailed view for selected torrent with sub-tabs (files, info, peers, trackers, graphs, config)
3. **Graphs Tab**: Global statistics and graphs (always visible in top half)
4. **Preferences Tab**: Configuration with nested sub-tabs

### Container vs Screen

- **Container widgets**: Used for tab content (e.g., `TorrentsTabContent`, `PerTorrentTabContent`)
- **Screen classes**: Used for full-screen overlays (e.g., `AddTorrentScreen`, `ConfigScreen`)
- **Never embed Screen in Container**: Use wrapper widgets (`MonitoringScreenWrapper`, `ConfigScreenWrapper`) to extract data from screens

## References

- Main dashboard: [ccbt/interface/terminal_dashboard.py](mdc:ccbt/interface/terminal_dashboard.py)
- Data provider: [ccbt/interface/data_provider.py](mdc:ccbt/interface/data_provider.py)
- Command executor: [ccbt/interface/commands/executor.py](mdc:ccbt/interface/commands/executor.py)
- Base screens: [ccbt/interface/screens/base.py](mdc:ccbt/interface/screens/base.py)
- Widgets: [ccbt/interface/widgets/](mdc:ccbt/interface/widgets/)
- Textual docs: https://textual.textualize.io/

---
description: Terminal dashboard implementation patterns using Textual framework
globs: ccbt/interface/**/*.py
---

# Terminal Dashboard Implementation Guide

This rule covers patterns and best practices for implementing the Textual-based terminal dashboard in `ccbt/interface/`.

## Module Structure

The interface module follows a modular architecture:

```
ccbt/interface/
├── terminal_dashboard.py    # Main App class and entry points
├── widgets/                 # Reusable UI components
│   ├── core_widgets.py     # Overview, TorrentsTable, PeersTable, SpeedSparklines
│   └── reusable_widgets.py # ProgressBarWidget, MetricsTableWidget, SparklineGroup
├── screens/                 # Screen components
│   ├── base.py             # Base classes (ConfigScreen, MonitoringScreen)
│   ├── dialogs.py          # Modal dialogs (AddTorrentScreen)
│   ├── monitoring/         # Monitoring screens (15 screens)
│   ├── config/             # Configuration screens (7 screens)
│   └── utility/            # Utility screens (Help, Navigation, FileSelection)
└── commands/               # Command execution
    └── executor.py         # CommandExecutor class
```

## Import Patterns

### Textual Import Handling

Always use TYPE_CHECKING blocks and fallback classes for Textual imports:

```python
from __future__ import annotations

from typing import TYPE_CHECKING, Any, ClassVar

if TYPE_CHECKING:
    from textual.app import App, ComposeResult
    from textual.screen import Screen
    from textual.widgets import Static, DataTable
else:
    try:
        from textual.app import App, ComposeResult
        from textual.screen import Screen
        from textual.widgets import Static, DataTable
    except ImportError:
        # Fallback classes for when textual is not available
        class App:  # type: ignore[misc]
            """Fallback App class when textual is not available."""
        
        class Screen:  # type: ignore[no-redef]
            """Fallback Screen class."""
        
        class Static:  # type: ignore[no-redef]
            """Fallback Static widget."""
        
        ComposeResult = None  # type: ignore[assignment, misc]
```

### Container Imports

For containers, handle the fallback case:

```python
try:
    from textual.containers import Container, Horizontal, Vertical
except ImportError:
    from typing import Any as ComposeResult
    Container = None  # type: ignore[assignment, misc]
    Horizontal = None  # type: ignore[assignment, misc]
    Vertical = None  # type: ignore[assignment, misc]
```

## Screen Implementation

### Base Screen Pattern

All screens should inherit from base classes in [ccbt/interface/screens/base.py](mdc:ccbt/interface/screens/base.py):

- **MonitoringScreen**: For monitoring/metrics screens
- **ConfigScreen**: For configuration screens
- **Screen**: For utility screens

Example monitoring screen:

```python
from ccbt.interface.screens.base import MonitoringScreen

class SystemResourcesScreen(MonitoringScreen):  # type: ignore[misc]
    """Screen to display system resource usage."""
    
    CSS = """
    #content {
        height: 1fr;
        overflow-y: auto;
    }
    """
    
    def compose(self) -> ComposeResult:  # pragma: no cover
        """Compose the screen."""
        yield Header()
        with Vertical():
            yield Static(id="content")
        yield Footer()
    
    async def _refresh_data(self) -> None:  # pragma: no cover
        """Refresh screen data."""
        content = self.query_one("#content", Static)
        # Update content...
```

### CSS Patterns

- Define CSS as class variable `CSS` (string)
- Use `#id` selectors for specific widgets
- Use layout containers: `height: 1fr` for flexible sizing
- Use `overflow-y: auto` for scrollable content
- Reference Textual design tokens: `$primary`, `$surface`, etc.

### Compose Pattern

Always use the `compose()` method with `yield`:

```python
def compose(self) -> ComposeResult:  # pragma: no cover
    """Compose the screen."""
    yield Header()
    with Vertical():
        yield Static(id="content")
        yield DataTable(id="table")
    yield Footer()
```

### Event Handling

- Use `on_mount()` for initialization
- Use `on_unmount()` for cleanup
- Use `action_*` methods for keyboard bindings
- Use `on_*` methods for widget events (e.g., `on_button_pressed`)

### Bindings

Define keyboard bindings as class variable:

```python
BINDINGS: ClassVar[list[tuple[str, str, str]]] = [
    ("escape", "back", "Back"),
    ("q", "quit", "Quit"),
    ("r", "refresh", "Refresh"),
]
```

## Widget Implementation

### Widget Base Classes

Widgets extend Textual widgets (usually `Static`):

```python
from textual.widgets import Static

class Overview(Static):  # type: ignore[misc]
    """Simple widget to render global stats."""
    
    def update_from_stats(self, stats: dict[str, Any]) -> None:
        """Update widget with statistics."""
        # Use Rich for formatting
        from rich.table import Table
        from rich.panel import Panel
        
        table = Table()
        # Build table...
        self.update(Panel(table, title="Overview"))
```

### Widget Patterns

- Use `update()` method to change widget content
- Use Rich library for formatting (Table, Panel, etc.)
- Keep widgets focused on single responsibility
- Export widgets through `widgets/__init__.py`

## Configuration Screens

Configuration screens inherit from `ConfigScreen`:

```python
from ccbt.interface.screens.base import ConfigScreen

class SSLConfigScreen(ConfigScreen):  # type: ignore[misc]
    """Screen to manage SSL/TLS configuration."""
    
    CSS = """..."""
    BINDINGS: ClassVar[list[tuple[str, str, str]]] = [...]
    
    def compose(self) -> ComposeResult:
        """Compose configuration screen."""
        # Use ConfigValueEditor and ConfigSectionWidget from
        # ccbt/interface/screens/config/widgets.py
```

## Command Execution

Use `CommandExecutor` from [ccbt/interface/commands/executor.py](mdc:ccbt/interface/commands/executor.py) to execute CLI commands:

```python
from ccbt.interface.commands.executor import CommandExecutor

class MyScreen(Screen):
    def __init__(self, session, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.session = session
        self._command_executor = CommandExecutor(session)
    
    async def action_some_command(self):
        """Execute a CLI command."""
        result = await self._command_executor.execute_command(
            "download", ["--torrent", "path/to/file.torrent"]
        )
```

## Module Exports

### Widgets Module

Export all widgets in [ccbt/interface/widgets/__init__.py](mdc:ccbt/interface/widgets/__init__.py):

```python
from ccbt.interface.widgets.core_widgets import (
    Overview,
    PeersTable,
    SpeedSparklines,
    TorrentsTable,
)
from ccbt.interface.widgets.reusable_widgets import (
    MetricsTableWidget,
    ProgressBarWidget,
    SparklineGroup,
)

__all__ = [
    "MetricsTableWidget",
    "Overview",
    "PeersTable",
    "ProgressBarWidget",
    "SparklineGroup",
    "SpeedSparklines",
    "TorrentsTable",
]
```

### Screens Module

Export base classes in [ccbt/interface/screens/__init__.py](mdc:ccbt/interface/screens/__init__.py). Individual screens are imported directly from their modules.

## Main Dashboard

The main dashboard in [ccbt/interface/terminal_dashboard.py](mdc:ccbt/interface/terminal_dashboard.py) contains:

- `TerminalDashboard` class (extends `App`)
- `run_dashboard()` function
- `main()` function (CLI entry point)

All screens and widgets are imported from their respective modules.

## Rich Integration

Use Rich library for formatting:

- `Panel`: For bordered content areas
- `Table`: For tabular data
- Rich markup: `[bold]`, `[cyan]`, `[green]`, etc.

Example:

```python
from rich.panel import Panel
from rich.table import Table

table = Table(title="Metrics", expand=True)
table.add_column("Metric", style="cyan", ratio=1)
table.add_column("Value", style="green", ratio=2)
table.add_row("CPU", "45%")

content.update(Panel(table, title="System Resources"))
```

## Type Hints

- Use `ComposeResult` for `compose()` return type
- Use `TYPE_CHECKING` blocks for type-only imports
- Use `# type: ignore[misc]` for Textual base classes
- Use `# pragma: no cover` for UI code that's hard to test

## Error Handling

- Always handle Textual import failures gracefully
- Use try/except blocks for async operations
- Display errors in UI using Rich Panels with `border_style="red"`

## Testing Considerations

- Mark UI code with `# pragma: no cover`
- Use integration tests for screen behavior
- Mock Textual widgets in unit tests
- Test fallback behavior when Textual is unavailable


## References

- Main dashboard: [ccbt/interface/terminal_dashboard.py](mdc:ccbt/interface/terminal_dashboard.py)
- Base screens: [ccbt/interface/screens/base.py](mdc:ccbt/interface/screens/base.py)
- Widgets: [ccbt/interface/widgets/](mdc:ccbt/interface/widgets/)
- Textual docs: https://textual.textualize.io/

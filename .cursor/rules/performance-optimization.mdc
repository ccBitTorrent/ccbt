---
globs: ccbt/disk_io.py,ccbt/async_peer_connection.py,ccbt/buffers.py,ccbt/network_optimizer.py
description: Performance optimization patterns and requirements
---

# Performance Optimization Patterns

## Zero-Copy Operations
Located in [ccbt/buffers.py](mdc:ccbt/buffers.py):

### Ring Buffers
- **High-Throughput**: Ring buffers for zero-copy data transfer
- **Memory Pools**: Pre-allocated memory pools for frequent allocations
- **Buffer Management**: Efficient buffer lifecycle management

```python
class RingBuffer:
    def __init__(self, size: int):
        self.buffer = bytearray(size)
        self.head = 0
        self.tail = 0
    
    def write(self, data: bytes) -> int:
        # Zero-copy write operation
        pass
```

## Network I/O Optimization
Located in [ccbt/network_optimizer.py](mdc:ccbt/network_optimizer.py):

### Socket Tuning
- **TCP_NODELAY**: Disable Nagle's algorithm for low latency
- **SO_REUSEPORT**: Enable port reuse for load balancing
- **Buffer Sizing**: Optimize socket buffer sizes based on BDP
- **Connection Pooling**: Reuse connections for efficiency

### Adaptive Connection Limits
Located in [ccbt/peer/connection_pool.py](mdc:ccbt/peer/connection_pool.py):
- **Adaptive Limit Calculation**: `_calculate_adaptive_limit()` dynamically adjusts max connections based on:
  - CPU usage (reduce if > threshold, default 80%)
  - Memory usage (reduce if > threshold, default 80%)
  - Peer performance (increase if peers performing well)
  - Formula: `base_limit * cpu_factor * memory_factor * performance_factor`
  - Bounded by `connection_pool_adaptive_limit_min` and `connection_pool_adaptive_limit_max`
- **Performance-Based Recycling**: Low-performing connections are recycled when:
  - Performance score < threshold (default 0.3)
  - Consecutive failures > max (default 5)
  - Idle time > max_idle_time (default 300s) AND new peer available
  - Bandwidth below minimum thresholds
- **Bandwidth Measurement**: Tracks download/upload bandwidth per connection with periodic updates (default 5s interval)
- **Progressive Health Degradation**: Connection health levels (HEALTHY, DEGRADED, UNHEALTHY) based on idle time, usage, errors, and bandwidth
- **Connection Quality Scoring**: `_calculate_connection_quality()` scores connections (0.0-1.0) based on bandwidth, latency, and error rate. Used to prefer high-quality connections in `acquire()`.

```python
class NetworkOptimizer:
    def optimize_socket(self, sock: socket.socket) -> None:
        sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEPORT, 1)
```

## Disk I/O Enhancement
Located in [ccbt/disk_io.py](mdc:ccbt/disk_io.py):

### io_uring Support (Linux)
- **Asynchronous I/O**: Use io_uring for high-performance I/O
- **Batch Operations**: Batch multiple I/O operations
- **Zero-Copy I/O**: Direct memory access for large transfers

### AIO Fallback
- **Cross-Platform**: AIO fallback for non-Linux systems
- **Async I/O**: Asynchronous file operations
- **Error Handling**: Proper error handling for I/O operations

### NVMe Optimizations
- **Direct I/O**: Bypass page cache for large sequential writes
- **Write-Behind Caching**: Optimize write performance
- **SSD Detection**: Detect SSD storage for optimization

```python
class DiskIO:
    async def write_piece(self, piece_data: bytes, offset: int) -> None:
        if self.use_io_uring:
            await self._io_uring_write(piece_data, offset)
        else:
            await self._aio_write(piece_data, offset)
```

## Hash Verification Optimization
Located in [ccbt/async_piece_manager.py](mdc:ccbt/async_piece_manager.py):

### SIMD-Accelerated SHA-1
- **OpenSSL Integration**: Use OpenSSL for SIMD-accelerated hashing
- **Batch Verification**: Verify multiple pieces simultaneously
- **Hash Caching**: Cache partial piece hashes

```python
class HashVerifier:
    def verify_piece(self, piece_data: bytes, expected_hash: bytes) -> bool:
        # SIMD-accelerated SHA-1 verification
        actual_hash = hashlib.sha1(piece_data).digest()
        return actual_hash == expected_hash
```

## Memory Optimization

### Memory Pools
- **Pre-allocation**: Pre-allocate memory pools for frequent operations
- **Object Reuse**: Reuse objects to reduce garbage collection
- **Memory Mapping**: Use memory mapping for large files

### Garbage Collection
- **Generational GC**: Optimize for generational garbage collection
- **Weak References**: Use weak references where appropriate
- **Memory Profiling**: Profile memory usage for optimization

## Adaptive Algorithms

### Adaptive Intervals
- **DHT Adaptive Intervals**: Located in [ccbt/discovery/dht.py](mdc:ccbt/discovery/dht.py). `_calculate_adaptive_interval()` adjusts DHT refresh intervals based on:
  - Base interval from config
  - Node quality and reachability
  - Network conditions
  - Bounded by `dht_adaptive_interval_min` and `dht_adaptive_interval_max`
- **Tracker Adaptive Intervals**: Located in [ccbt/discovery/tracker.py](mdc:ccbt/discovery/tracker.py). `_calculate_adaptive_interval()` adjusts announce intervals based on:
  - Tracker performance (response time, success rate)
  - Peer count from tracker
  - Swarm health
  - Bounded by `tracker_adaptive_interval_min` and `tracker_adaptive_interval_max`
- **Tracker Performance Ranking**: `rank_trackers()` sorts trackers by performance score considering:
  - Response time (lower = better)
  - Success rate (higher = better)
  - Peer quality (average peer download rate)
  - Recent failures

### Bandwidth-Aware Optimizations
- **Request Prioritization**: Located in [ccbt/peer/async_peer_connection.py](mdc:ccbt/peer/async_peer_connection.py). `_calculate_request_priority()` incorporates peer download rate into priority calculation. `RequestInfo.bandwidth_estimate` stores estimated bandwidth for load balancing.
- **Request Load Balancing**: `_balance_requests_across_peers()` distributes requests proportionally based on peer bandwidth:
  - Calculates total available bandwidth
  - Distributes requests proportionally to each peer's share
  - Considers peer pipeline capacity
  - Handles edge cases gracefully
- **Bandwidth-Weighted Piece Selection**: Located in [ccbt/piece/async_piece_manager.py](mdc:ccbt/piece/async_piece_manager.py). Piece selection strategies consider peer download speeds when scoring pieces.

### Performance-Based Peer Management
- **Peer Ranking**: `_rank_peers_for_connection()` ranks peers before connection based on historical performance, reputation, connection success rate, and source quality.
- **Peer Performance Evaluation**: `_evaluate_peer_performance()` calculates performance scores (0.0-1.0) from download rate, upload rate, latency, error rate, and connection stability.
- **Peer Recycling**: Low-performing peers are automatically recycled when better peers are available, improving overall swarm efficiency.

## Performance Targets
- **50% improvement** in download speed
- **30% reduction** in memory usage
- **40% improvement** in disk I/O throughput
- **Sub-100ms** peer connection establishment
- **Adaptive algorithms** dynamically optimize based on real-time conditions

## Benchmarking
- **Performance Tests**: Regular performance regression testing
- **Load Testing**: High-load scenario testing
- **Memory Profiling**: Memory usage analysis
- **CPU Profiling**: CPU usage optimization